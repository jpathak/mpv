// Auto-generated from metal_shaders.metal
// Do not edit manually

"/*\n"
" * This file is part of mpv.\n"
" *\n"
" * mpv is free software; you can redistribute it and/or\n"
" * modify it under the terms of the GNU Lesser General Public\n"
" * License as published by the Free Software Foundation; either\n"
" * version 2.1 of the License, or (at your option) any later version.\n"
" *\n"
" * mpv is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" * GNU Lesser General Public License for more details.\n"
" *\n"
" * You should have received a copy of the GNU Lesser General Public\n"
" * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.\n"
" */\n"
"\n"
"#include <metal_stdlib>\n"
"#include <simd/simd.h>\n"
"\n"
"using namespace metal;\n"
"\n"
"// Vertex data structure\n"
"struct VertexIn {\n"
"    float2 position [[attribute(0)]];\n"
"    float2 texcoord [[attribute(1)]];\n"
"};\n"
"\n"
"struct VertexOut {\n"
"    float4 position [[position]];\n"
"    float2 texcoord;\n"
"};\n"
"\n"
"// Basic vertex shader\n"
"vertex VertexOut vertex_basic(VertexIn in [[stage_in]],\n"
"                              constant float4x4& mvp [[buffer(0)]]) {\n"
"    VertexOut out;\n"
"    out.position = mvp * float4(in.position, 0.0, 1.0);\n"
"    out.texcoord = in.texcoord;\n"
"    return out;\n"
"}\n"
"\n"
"// Fullscreen triangle vertex shader (no vertex buffer needed)\n"
"vertex VertexOut vertex_fullscreen(uint vid [[vertex_id]]) {\n"
"    VertexOut out;\n"
"    \n"
"    // Generate fullscreen triangle\n"
"    float2 positions[3] = {\n"
"        float2(-1.0, -1.0),\n"
"        float2( 3.0, -1.0),\n"
"        float2(-1.0,  3.0)\n"
"    };\n"
"    \n"
"    float2 texcoords[3] = {\n"
"        float2(0.0, 1.0),\n"
"        float2(2.0, 1.0),\n"
"        float2(0.0, -1.0)\n"
"    };\n"
"    \n"
"    out.position = float4(positions[vid], 0.0, 1.0);\n"
"    out.texcoord = texcoords[vid];\n"
"    return out;\n"
"}\n"
"\n"
"// Basic texture sampling fragment shader\n"
"fragment float4 fragment_texture(VertexOut in [[stage_in]],\n"
"                                 texture2d<float> tex [[texture(0)]],\n"
"                                 sampler samp [[sampler(0)]]) {\n"
"    return tex.sample(samp, in.texcoord);\n"
"}\n"
"\n"
"// YUV to RGB conversion matrices\n"
"constant float3x3 yuv_to_rgb_bt601 = float3x3(\n"
"    float3(1.0,     1.0,    1.0),\n"
"    float3(0.0,    -0.344,  1.772),\n"
"    float3(1.402,  -0.714,  0.0)\n"
");\n"
"\n"
"constant float3x3 yuv_to_rgb_bt709 = float3x3(\n"
"    float3(1.0,     1.0,    1.0),\n"
"    float3(0.0,    -0.187,  1.856),\n"
"    float3(1.575,  -0.468,  0.0)\n"
");\n"
"\n"
"// YUV420 planar video rendering\n"
"fragment float4 fragment_yuv420(VertexOut in [[stage_in]],\n"
"                                texture2d<float> tex_y [[texture(0)]],\n"
"                                texture2d<float> tex_uv [[texture(1)]],\n"
"                                sampler samp [[sampler(0)]],\n"
"                                constant int& color_space [[buffer(0)]]) {\n"
"    float y = tex_y.sample(samp, in.texcoord).r;\n"
"    float2 uv = tex_uv.sample(samp, in.texcoord).rg;\n"
"    \n"
"    float3 yuv = float3(y, uv.x - 0.5, uv.y - 0.5);\n"
"    \n"
"    // Select color matrix based on color space\n"
"    float3x3 mat = (color_space == 0) ? yuv_to_rgb_bt601 : yuv_to_rgb_bt709;\n"
"    float3 rgb = mat * yuv;\n"
"    \n"
"    return float4(rgb, 1.0);\n"
"}\n"
"\n"
"// Color correction shader\n"
"fragment float4 fragment_color_correct(VertexOut in [[stage_in]],\n"
"                                       texture2d<float> tex [[texture(0)]],\n"
"                                       sampler samp [[sampler(0)]],\n"
"                                       constant float& brightness [[buffer(0)]],\n"
"                                       constant float& contrast [[buffer(1)]],\n"
"                                       constant float& saturation [[buffer(2)]],\n"
"                                       constant float& gamma [[buffer(3)]]) {\n"
"    float4 color = tex.sample(samp, in.texcoord);\n"
"    \n"
"    // Apply brightness and contrast\n"
"    color.rgb = (color.rgb - 0.5) * contrast + 0.5 + brightness;\n"
"    \n"
"    // Apply saturation\n"
"    float luminance = dot(color.rgb, float3(0.299, 0.587, 0.114));\n"
"    color.rgb = mix(float3(luminance), color.rgb, saturation);\n"
"    \n"
"    // Apply gamma correction\n"
"    color.rgb = pow(color.rgb, float3(1.0 / gamma));\n"
"    \n"
"    return color;\n"
"}\n"
"\n"
"// Simple OSD/subtitle overlay shader\n"
"fragment float4 fragment_overlay(VertexOut in [[stage_in]],\n"
"                                 texture2d<float> tex_video [[texture(0)]],\n"
"                                 texture2d<float> tex_overlay [[texture(1)]],\n"
"                                 sampler samp [[sampler(0)]]) {\n"
"    float4 video = tex_video.sample(samp, in.texcoord);\n"
"    float4 overlay = tex_overlay.sample(samp, in.texcoord);\n"
"    \n"
"    // Alpha blend overlay on top of video\n"
"    return mix(video, overlay, overlay.a);\n"
"}\n"
"\n"
"// Compute shader for image processing (e.g., scaling, filtering)\n"
"kernel void compute_scale(texture2d<float, access::read> src [[texture(0)]],\n"
"                          texture2d<float, access::write> dst [[texture(1)]],\n"
"                          constant float2& scale [[buffer(0)]],\n"
"                          uint2 gid [[thread_position_in_grid]]) {\n"
"    // Check bounds\n"
"    if (gid.x >= dst.get_width() || gid.y >= dst.get_height()) {\n"
"        return;\n"
"    }\n"
"    \n"
"    // Calculate source coordinates\n"
"    float2 src_coord = float2(gid) / scale;\n"
"    \n"
"    // Bilinear sampling\n"
"    uint2 src_size = uint2(src.get_width(), src.get_height());\n"
"    float2 texel = src_coord - 0.5;\n"
"    uint2 p0 = uint2(clamp(texel, float2(0), float2(src_size - 1)));\n"
"    uint2 p1 = uint2(clamp(texel + 1, float2(0), float2(src_size - 1)));\n"
"    \n"
"    float2 f = fract(texel);\n"
"    \n"
"    float4 c00 = src.read(uint2(p0.x, p0.y));\n"
"    float4 c10 = src.read(uint2(p1.x, p0.y));\n"
"    float4 c01 = src.read(uint2(p0.x, p1.y));\n"
"    float4 c11 = src.read(uint2(p1.x, p1.y));\n"
"    \n"
"    float4 result = mix(mix(c00, c10, f.x), mix(c01, c11, f.x), f.y);\n"
"    dst.write(result, gid);\n"
"}\n"
"\n"
"// HDR tone mapping shader\n"
"fragment float4 fragment_hdr_tonemap(VertexOut in [[stage_in]],\n"
"                                     texture2d<float> tex [[texture(0)]],\n"
"                                     sampler samp [[sampler(0)]],\n"
"                                     constant float& exposure [[buffer(0)]],\n"
"                                     constant float& max_luminance [[buffer(1)]]) {\n"
"    float4 color = tex.sample(samp, in.texcoord);\n"
"    \n"
"    // Apply exposure\n"
"    color.rgb *= exposure;\n"
"    \n"
"    // Reinhard tone mapping\n"
"    float luminance = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));\n"
"    float mapped_lum = luminance / (1.0 + luminance / max_luminance);\n"
"    color.rgb *= mapped_lum / luminance;\n"
"    \n"
"    // Gamma correction for display\n"
"    color.rgb = pow(color.rgb, float3(1.0 / 2.2));\n"
"    \n"
"    return color;\n"
"}\n"
"\n"
"// Deinterlacing shader (bob method)\n"
"fragment float4 fragment_deinterlace(VertexOut in [[stage_in]],\n"
"                                     texture2d<float> tex [[texture(0)]],\n"
"                                     sampler samp [[sampler(0)]],\n"
"                                     constant int& field [[buffer(0)]]) {\n"
"    float2 coord = in.texcoord;\n"
"    float2 texel_size = 1.0 / float2(tex.get_width(), tex.get_height());\n"
"    \n"
"    // Adjust vertical coordinate based on field\n"
"    if (field == 0) {\n"
"        // Even field\n"
"        coord.y = coord.y * 0.5;\n"
"    } else {\n"
"        // Odd field\n"
"        coord.y = coord.y * 0.5 + 0.5;\n"
"    }\n"
"    \n"
"    return tex.sample(samp, coord);\n"
"}"
